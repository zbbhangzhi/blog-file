#### Redis持久化

持久化用于Redis实例因宕机等原因而重启时恢复数据，Redis的持久化机制有两种方式：快照和AOF日志。

##### 快照RDB

是一次**全量备份**，遍历整个内存（会过滤已过期但未被删除的键），大块写内存**数据的二进制**序列化形式到磁盘，存储的十分紧凑，这个过程系统负载很高，所以一般从节点执行，当然有可能会出现网络分区/从节点宕机导致数据不一致和数据丢失的问题；（当服务器以主服务加载时会过滤已过期的键，以从服务加载时不会）

（TODO什么时候执行 既然是全量数据）

- 问题一

  快照的实现其实是内存数据的另一种存储，那么这个过程就涉及到了文件IO操作，但是Redis的主线程的一个特性多路复用，文件IO操作是不能使用多路复用API的（为什么），那么这个主线程同时在除了客户端请求的时候还需要进行文件IO操作，那么可能会造成线程阻塞，不能很快响应客户端的请求；

- 问题二

  同时，主线程在对数据的更新的时候，正好在做持久化，等更新完这个数据也变了，会造成快照与内存数据不一致。

- 解决

  使用操作系统Linux的多进程**copy on write**机制实现。

  持久化时redis调用glibc的函数fork产生一个**子进程**（这个过程也称为进程分离）用于快照持久化，子进程是和父进程共享内存数据的不论是代码段还是数据段。

  子进程在工作时，通过对现有数据结构（当前过程数据是定格的不受父进程修改影响）遍历读取并序列化写到磁盘，保证不修改现有内存数据结构。

  但是父进程是会一直对内存数据结构修改的，这时候会用到操作系统COW机制来进行数据段页面（数据段由很多操作系统页组成）的分离，当一个页面的数据被父进程修改，那么会将被**共享的页面**复制一份分离出来，并对这个复制的页面进行修改。（TODO这个复制页面被修改然后呢，怎么应用到内存数据里）所以子进程对应的页面并没有变化。

##### AOF日志

是连续的**增量备份**，存储的是内存数据修改的顺序**指令记录文本**，因为长时间的运行整个文件会变的很大，所以需要定期重写以瘦身。在平时的应用中，主节点一般只负责处理客户端的请求，从节点才负责持久化。

- 指令存储：Redis收到客户端的请求后先校验参数，然后**存入**到AOF日志中，最后再**执行**指令。这样既可以保证宕机时没能执行，重启后再重放一下指令。
- AOF文件重写：调用**bgrewriteaof**指令：开辟一个子进程对内存数据进行遍历**转换**成一系列redis操作指令（因为少了很多更新/删除操作，直接就是新增），序列化到一个新的AOF文件中，序列化完后如果有增量数据再追加到这个新的文件中，最后代替旧的文件。
- 日志丢失：但是AOF文件的写入过程其实两步：将内容写到内核为文件描述符分配的一个**内存缓存**中，再异步将脏数据**刷盘**（这里的脏数据难道不是AOF要的数据吗 为什么叫脏数据）。所以如果出现机器宕机可能会出现日志内容还没有刷盘，而导致日志丢失的问题。linux的glibc提供**fsync**函数将指定文件的内容强制从内核缓存刷到磁盘，如果实时执行就可以保证日志不丢失，但是因为这个函数执行十分的慢，所以不建议使用，让系统决定何时同步刷盘；或者设置强制刷盘时间，在保证安全的时候也提供高性能。

##### 混合持久化(4.0v)

一般重启后，不会直接使用快照方式来恢复内存数据，因为有很多数据其实是丢失的；如果使用AOF日志重放，它的性能相对快照是慢很多的。为此，Redis4.0提供了一种新的持久化方式混合持久化：将快照的内容和AOF日志文件存在一起，这样AOF文件内存的内容从全量内容改为增量内容。Redis重启的时候，可以先加载快照内容，再重放增量AOF日志。（TODO 怎么确定增量日志恢复时间节点，怎么无缝衔接）
