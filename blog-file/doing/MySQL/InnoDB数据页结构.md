InnoDB数据页结构

#### 定义

InnoDB管理存储空间的基本单位，一个页一般是16kb。InnoDB有多种类型的页用于存储不同信息。我们以记录为单位将数据存储在表中，所以存放记录的页又称数据页。数据页是一个双链表记录记录上下页信息。

#### 数据页结构

- file header文件头部(38byte)

  ​	描述页的基本信息，比如FIL_PAGE_OFFSET页号，FIL_PAGE_TYPE页类型（undo日志页/索引页/系统页...），FIL_PAGE_PREV上页FIL_PAGE_NEXT下页信息（促使数据页组成双链表结构），FIL_PAGE_SPACE_OR_CHKSUM页校验和。

- page header页面头部(56byte)

  ​	存储数据页中存储记录的状态值，比如第一条记录的地址，PAGE_N_DIR_SLOTS页目录中槽数量，PAGE_N_RECS本页的记录数量，PAGE_LAST_INSERT最后插入位置，PAGE_DIRECTION记录插入的方向，比较新插入和上一条记录的主键大小得知左右方向等

- Infimum + supremum最小大记录(26byte)

  ​	两条伪记录：记录头信息5bit+固定单词8bit Infimum /supremum；记录头信息中的heap_no为0和1，record_type为2和3

- user records用户数据(unkown)

  ​	存储记录。为更好的管理记录，InnoDB以指定的行格式(分析见下方)存储记录，根据记录的记录头信息管理记录

- free space 空闲空间(unkown)

  ​	每次插入记录都会从free space申请一个记录大小的空间到user records，如果用完就申请新的页

- page directory页目录(unkown)

  ​	为提高根据主键查询记录的效率，InnoDB模仿书本目录，设计了页目录，只存储每组最大那条记录的偏移位置即槽，并以二分法的方式查找，再遍历record_type属性；

  > - 将所有记录（包括最大最小，不包括已删除）划分为几个组
  > - 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的`n_owned`属性表示该记录拥有多少条记录，也就是该组内共有几条记录
  > - 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近`页`的尾部的地方，这个地方就是所谓的`Page Directory`，也就是`页目录`（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为`槽`（英文名：`Slot`），所以这个页面目录就是由`槽`组成的。
  > - 最小记录所在组只能有1条记录，最大记录所在组有1-8条，其他4-8条。
  > - 二分法确定目标记录所在槽，找到该槽中主键最小的那条记录
  > - 通过记录的next record遍历该槽所在的组中的各个记录

- file tailer文件尾部(8byte)

  ​	用于校验页是否完整，如果在写入磁盘事，系统断电，可记录终止的位置。前4byte：记录页的校验和；后4byte：页面最后被修改时对应的日志序列位置LSN

  ​	file header的校验和在修改后同步前计算，trailer的是原先的页的校验和，两相比较加上lsn不同则说明同步出错

##### 行格式

有四种类型compact等，以compact为例，如下图所示

![img](https://user-gold-cdn.xitu.io/2019/5/8/16a95c0feca77be3?imageslim)

###### 记录头信息

- delete mask删除标志位(1bit)：0否1是，被删除的记录实际仍存在页中，但删除标志位置1，且由删除记录的next_record属性形成一个被删除记录的垃圾链表（这个链表占用的空间为可重用空间，这些被删除记录占用的空间可能被后来新增的记录覆盖），以备之后重用这部分的存储空间。如果删除后还想再次将记录插入到表中，InnoDB会直接复用原来被删除记录的存储空间，并不会重新申请新的存储空间
- min_rec_mask：b+树的每层非叶子节点中的最小记录标志位
- n_owned：每组的最后一条记录记录整个组拥有的记录数
- heap_no：表示记录在页中的位置；0，1表示最小和最大记录，这两个记录每个页自动加入的，是伪记录，不存放在user records而是Infimum + Supremum部分
- record type当前记录类型：0普通记录，1b+树非叶节点记录，2最小记录，3最大记录
- next record：表示从当前记录的真实数据到下一个记录（根据主键大小排序的，不是按插入顺序）的真实数据的偏移量，形成一个**单链表**，头尾就是最小和最大记录；如果删除某一条记录，不光将delete mask置为1，并将其next record值置为0，将next record指向它的记录指向它的下一条记录 TDOO 为什么不直接存位置

#### 小结

> `InnoDB`数据页的7个组成部分，知道了各个数据页可以组成一个`双向链表`，而每个数据页中的记录会按照主键值从小到大的顺序组成一个`单向链表`，每个数据页都会为存储在它里边儿的记录生成一个`页目录`，在通过主键查找某条记录的时候可以在`页目录`中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录



如果主键id列自增，一条记录id为4被物理删除后，再新增一条记录，id为5；如果此时先新增一条记录id为7，再新增一条id会自增为8不会是6