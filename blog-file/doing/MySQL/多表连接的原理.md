### 多表连接的原理

连接就是把各个表中的记录都拿出来然后依次匹配加入到结果集中。连接查询中表A与表B连接查询，表A的每条记录和表B的每条记录相互匹配的组成结果集被称为**笛卡尔积**。

1. #### 连接查询过程

- 确定第一个表为**驱动表**，查询出驱动表中所有符合条件的结果集A
- 根据上一步查询出的结果集A，**循环查询**第二个表（被驱动表）与结果集A匹配的记录。比如结果集A找出3条符合的记录，那么被驱动表也要根据这些过滤条件查询3次表。

2. #### 连接分类

- 内连接：（`表A inner join/cross join/join/，表B`，左右表位置随意互换）驱动表中的记录在被驱动表中找不到匹配记录，该记录**不加入**到结果集中。

  内连接的where和on语句是等价的，都**不加入**被过滤的记录

- 外连接：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍要**加入**到结果集中
  - 左连接：（`表A left join 表B on 条件`）左侧表表A为驱动表
  - 右连接：（`表A right join 表B on 条件`）右侧表表B为驱动表
  - 但是使用外连接时不想把不匹配的空记录放到结果集中，可以更改筛选条件子句的使用方式达成。
    - where：不论内外连接，不符合条件的都**不加入**到结果集中
    - on：如果无法在被驱动表中找到过滤条件的记录，对应的被驱动表记录的列置为**null**放入到结果集中

3. #### 连接原理

- 嵌套循环连接

> ​	步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。
>
> ​	步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。

- 索引加快连接速度

基于嵌套循环连接，被驱动表使用到的搜索条件列置为**索引列**，二级索引+回表的代价低于全表扫描更低时才会使用索引

如果驱动表没有参与搜索条件，那么当被驱动表中的搜索条件是该表某个索引的一部分时，在不能用到eq_ref/ref/ref_or_null_range查询方法执行时，是可以使用索引扫描index的方法来查询被驱动表的，所以尽量不要用*表示查询列表

- 基于块的嵌套循环连接
  
  如果被驱动表索引进行访问，而需要减少被驱动表访问次数
  
  - 将表从磁盘加载到内存中，如果内存不足会先加载部分，等到加载到后面的记录时释放前面的记录
  - join buffer（默认256kb，`join_buffer_size`配置）：执行查询前申请一块固定大小的内存，然后把驱动表查出的**结果集**（只放入查询列和条件列，所以尽量不要*查询，这样能放很多条结果集记录）记录装在里面，每条被驱动表的记录一次性和join buffer中的多条驱动表记录做匹配，做完匹配后的一条记录会从内存中清除（也就是边加载边匹配join buffer和每条被驱动表记录，匹配就在内存中做）。

4. #### 连接优化

以上三种连接方法，最优是给被驱动表加上效率高的索引，其次是为机器调大join_buffer_size，只能选用一种。