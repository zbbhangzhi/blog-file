## 事务隔离级别和MVCC

每个客户端和服务器的一次连接，就是一个会话，而每个客户端可以在自己的会话中发出事务请求，一般来说一个服务器可以连接若干个客户端，所以一个服务器可以同时处理很多事务请求，但理论上某个事务在对某个数据在进行访问时，其他事务应该排队等待。但这样在高并发下会严重影响性能，所以只能设计事务隔离级别来兼顾事务的隔离性和提高多个事务的性能。

### 事务问题

如果事务执行不保证串行执行，也就是并发执行会遇到以下几个问题：

- 脏写：一个事务修改了另一个未提交事务修改过的数据

- 脏读：一个事务读到另一个未提交事务修改过的数据
- 不可重复读：一个事务能读到其他已提交事务修改过后的值，并且每次其他事务修改并提交，该事务都能查到最新值
- 幻读：一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，即读到了之前没有读到的记录

### 隔离级别

根据这几个问题，SQL标准设计了4个隔离级别，在不同程度上禁止了这些问题的发生。

- `READ UNCOMMITTED`隔离级别下，可能发生`脏读`、`不可重复读`和`幻读`问题。
- `READ COMMITTED`隔离级别下，可能发生`不可重复读`和`幻读`问题，但是不可以发生`脏读`问题。
- `REPEATABLE READ`隔离级别下，可能发生`幻读`问题（MySQL下禁止），但是不可以发生`脏读`和`不可重复读`的问题。
- `SERIALIZABLE`隔离级别下，各种问题都不可以发生。

InnoDB使用锁来保证脏写的情况不会发生。

### MVCC原理

（Multi-Version Concurrency Control ，多版本并发控制），MVCC指的就是在使用指的就是在使用`READ COMMITTD`、`REPEATABLE READ`这两种隔离级别的事务在执行普通的`SEELCT`操作时访问记录的版本链的过程，这样子可以使不同事务的`读-写`、`写-读`操作并发执行，从而提升系统性能。而剩下两种隔离级别执行普通select操作时的区别就是生成ReadView的时机不同；MVCC只在select查询时生效

#### 版本链

每条记录在插入时都会隐式的生成两个列：trix_id,roll_pointer，trix_id是它最新的事务id，在记录每次更新时，就会将旧值写入undo日志，并将roll_pointer指向它；每条undo日志也有自己roll_pointer属性和事务id属性，所以可以将这些记录根据roll_pointer串成一条链表（版本链），版本链的头节点就是当前记录的最新值

READUNCOMMITTED隔离级别的事务只需要读取版本链中最新的记录就可以了，不需要管它是否已经被提交

SERIALIZABLE隔离级别的事务需要加锁来访问记录

READ COMMITTED，REPEATABLE READ隔离级别的事务都是基于已提交的事务的，所以需要判断版本链中哪个版本是 对当前事务可见的，所以InnoDB中使用ReadView方式来判断

#### ReadView

ReadView由事务生成时创建

- m_ids：当前系统中活跃的读写事务的事务id列表
- min_trix_id：m_ids中最小值
- max_trix_id：应该分配给下个事务的id值
- creator_trix_id：生成该ReadView的事务的事务id

如何判断记录的某个版本是否对当前事务可见，如果不可见，就需要沿着版本链一直向下比较

- 被访问版本的trix_id=creator_trix_id，自己访问自己，可见
- 被访问版本的trix_id<min_trix_id，被访问记录事务已提交，可见
- 被访问版本的trix_id>max_trix_id，当前事务在被访问记录生成后开启，不可见
- 被访问版本的trix_id in (min_trix_id, max_trix_id),需要判断被访问版本的trxi_id是否在m_ids中，如果在则说明它的事务仍旧活跃，不可见；如果不在，说明已被提交，可见

##### READ COMMITTED

每次读取数据前都生成一个独立的ReadView，这样根据版本链依次判断，然后将可见的那个版本返回回去。

##### REPEATABLE READ

只在第一次读取数据时生成一个ReadView，后面的select重复使用一个ReadView



todo delete mask和MVCC的关系
