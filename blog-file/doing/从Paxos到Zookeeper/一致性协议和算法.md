### 一致性协议和算法

为解决分布式系统一致性问题，提出2PC/3PC协议，在一个事务跨越多个分布式节点时为保持ACID特性，引入协调者这个概念来统一调度所有分布式节点执行，并决定参与者节点是否要把事务提交，保证原子性操作。

TODO 2/3PC过程均为对其缺点提出解决方案，paxos就是解决方案

#### 2PC

二阶段提交被认为是一种一致性协议广泛用于关系型数据库，用于完成分布式事务的协调决定提交还是回滚，具有原子性和强一致性，它将事务的提交过程分成两个阶段，可以解决事务的原子问题。如mysql的事务提交。

- ##### 提交事务请求（尝试）
  
  - 协调者向所有参与者询问是否可以提交事务
  - 所有参与者执行事务，记录undo/redo信息到日志中
  - 成功完成事务执行的参与者反馈yes给协调者，失败的返回no
- ##### 执行事务提交（提交）
  
  - 协调者收到所有参与者的反馈都是yes
    - 协调者向所有参与者发送提交Commit请求
    - 参与者收到Commit请求后执行事务提交，更改日志信息，释放事务执行时占用的资源
    - 事务提交后，参与者向协调者发送ack消息
    - 协调者收到所有参与者的ack消息，事务完成
  - 协调者收到的反馈有no或者超时未收到参与者的反馈，中断事务
    - 协调者向所有参与者发送回滚请求
    - 参与者收到rollback请求，利用记录的undo信息执行回滚，完成后回滚执行期内占用的资源
    - 参与者完成回滚后，反馈给协调者ack消息
    - 协调者收到所有ack消息后，执行事务中断
  
  ##### 二阶段的执行过程简单易懂，但缺点明显：
  
- 同步阻塞：事务执行过程中会一直占用资源导致同步阻塞，而整个事务的执行过程中有很多等待其他参与者响应的过程。（3PC增加超时提交以解决，减少同步阻塞发生范围）
- 单点问题：整个事务执行的过程中只有一个协调者在与所有参与者响应，如果协调者挂了，那么所有参与者都将处于资源锁定的阶段，无法执行下一步操作；可以用新的协调者替换，但无法解决因协调者宕机，参与者处于阻塞问题todo。（3PC引入超时机制，使参与者继续达成一致）
- 数据不一致：在协调者向所有参与者发送commit请求后，网络或协调者所在机器异常，导致部分commit被参与者接收，并提交了事务，而剩下没有收到请求的参与者就无法提交；协调者发送完commit请求后和参与者都挂了，新协调者不能指定到底之前执行的commit还是rollback
- 不可靠：如果一个参与者故障而协调者不能收到它的响应，协调者会根据自身的超时机制判断是否要中断事务，一般就是一个节点失败整个事务失败，没有相应的容错机制

#### 3PC

- ##### CanCommit

  - 协调者向所有参与者发送can commit请求，询问是否可以提交事务
  - 收到请求后，参与者认为自身可以执行事务后反馈yes给协调者进入预备状态，或反馈no

- ##### PreCommit

  - 所有参与者响应yes
    - 向所有参与者发送预提交preCommit请求，进入prepared阶段
    - 参与者收到请求，执行事务操作，记录undo/redo信息到日志
    - 参与者执行完事务后向协调者发送ack响应，并等待协调者的最终指令提交或终止
  - 任一参与者反馈no，或协调者在一个超时时间后没有收到所有参与者的反馈
    - 向所有参与者发送abort请求
    - 参与者收到请求后中断事务，或在超时时间后没收到协调者消息也中断事务

- ##### Do Commit

  - 执行提交
    - 协调者收到所有参与者的ack响应，状态从预提交改为提交，并向所有参与者发送do commit请求
    - 参与者收到请求后正式执行事务提交操作，完成后释放执行事务时占用的资源，如果超时没有收到也会提交事务
    - 参与者完成事务提交后向协调者发送ack消息
    - 协调者收到所有ack请求后，完成事务
  - 任一参与者反馈no，或协调者在一个超时时间后没有收到所有参与者的反馈
    - 向所有参与者发送abort请求
    - 参与者收到请求后根据undo/redo日志执行回滚操作，并释放占用资源
    - 参与者完成事务回滚后向协调者发送ack消息
    - 协调者收到所有ack请求后，中断事务

  ##### 与2PC相比改进：
  
  ​	参与者在诸如协调者挂了或者协调者和参与者网络问题导致的超时时间外无法收到协调者消息都会继续执行事务提交，避免了二阶段提交带来的大范围阻塞问题，在出现单点故障后依旧继续执行，但是如果在pre commit阶段，参与者无法和协调者正常通信，协调者依旧会继续执行事务的提交（超时机制，因为它认为大概率是会提交的），出现数据不一致性

#### Paxos

一致性算法有三个参与角色，processor生成提案，acceptor批准提案，learner提案获取，这三个角色之间可以轮换，避免了分布式单点问题，且集合3PC的precommit过程解决了2PC的无限期等待，脑裂等问题，保证：

1. 一次提案只有一个被选中

 	2. 如果没有提案被选中就不会有选中的提案
 	3. 一个提案被选中后，所有进程都可以获取这个被选中的提案信息

提案选定过程算法类似于二阶段提交，每个提案被生成后自身协调一个编号，生成越晚编号越大

- ##### 阶段一（生成提案，少数服从多数）
  
  - proposer选中一个编号为Mn的提案，向Acceptor的某个超半数的子集成员发送编号Mn的**prepare**请求（1.必须比之前已被半数批准的最大编号提案大2.如果acceptor已接收其他提案则返回小于Mn但最大的提案编号）
  
    这里规定只有主proposer才能提出议案，只有主proposer才能和过半Acceptor通信，避免多个proposer不断提出更大的提案导致选定过程死循环
  
  - Acceptor收到请求后，判断这个Mn编号的prepare请求是否大于它之前已经批准过的最大编号的提案，是的话反馈proposer它已经将提案改为Mn，并承诺之后的提案都会大于Mn，~~如果一旦发现提案编号更大之前的提案将被丢弃，~~并将当前响应的最大prepare请求的编号响应给proposer
  
  - proposer收到半数以上acceptor的响应，它就产生编号为Mn,Vn（Vn是所有响应中最大编号的值）的提案；如果超半数响应没有提案，即acceptor没有批准过任何提案，Vn值由proposer决定
- ##### 阶段二（批准提案）
  
  - 如果proposer收到来自超半数acceptor的提案Mn响应，那么就会将（Mn，Vn）提案的**Accept**请求发给acceptor
  - Acceptor收到（Mn，Vn）提案的Accept请求，如果它尚未对大于Mn提案的prepare请求作响应就会通过这个提案，不然就忽略

- ##### 提案获取过程

​	Acceptor将批准的方案发送给一个特定的Learner集合，集合中任意learner都可以将确定的提案通知给其他learner，集合个数越多，可靠性越强
