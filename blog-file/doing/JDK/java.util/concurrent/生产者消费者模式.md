## 生产者消费者模式

生产者/消费者线程是两种独立的线程，是一种将串行化的动作并发化的模型；生产者/消费者线程各自可以是多个，且它们共用一个用于传递产品的传输通道，一般由线程安全的队列来实现。

todo 生产者线程发布产品到传输通道时，怎么保证的线程安全

todo 日志读取线程代码实现（统计数据日志+读取并填充日志到指定记录及集或称写入本地文件）

### 传输通道

#### 阻塞队列

##### 定义

> - 阻塞式
>
> 当消费者线程消费时，发现通道中没有产品可以消费（非满），就会暂停等待，当生产者线程成功往通道中发布产品后，就会唤醒等待的消费者线程；如果生产者线程生产时发现通道已满（非空），就会暂停等待，当消费者线程成功消费一个商品后，就会唤醒等待的生产者线程。
>
> 阻塞式队列的缺点就是会产生上下文切换，如ReetrantLock.lock()就是一个阻塞式方法
>
> - 非阻塞式
>
> 任意一个操作不会导致线程阻塞

##### 实现

BlockingQueue

```java
//阻塞式
//put
//take
//非阻塞式
//offer
//poll
```

- 有界队列

  程序指定容量，适用于产生生产速度大于产品消费速度，可能造成产品积压的场景，这样能够适当暂停生产者线程，降低生产速率

  - ArrayBlockingQueue：（支持put&take操作的公平/非公平调度）内部维护一个数组存储元素，其存储空间是预先分配的，put/take操作不会增加垃圾回收的负担；且元素的put与take使用的同一个显式锁，可能造成锁的较高争用，导致较多的上下文切换，适合生产者线程和消费者线程并发度较低的场景。
  - LinkedBlockingQueue（优先）：（非公平调度）可在构造器中指定容量，内部维护一个链表，那么它的存储空间是动态分配的，put/take操作可能会增加垃圾回收的负担；但put/take操作使用不同的锁，所以使用原子类来维护它的链表长度，可能产生额外开销，适合生产者线程和消费者线程并发度较高的场景。
  - SynchronousQueue：（公平/非公平调度）内部不维护容器存储元素，适合生产即消费场景，它俩的产品处理能力差别不大，如果生产者线程生产了产品时，没有消费者消费，生产者线程就会暂停，直到产品被消费；消费者同理。

- 无界队列：Integer.MAX_VALUE

  - LinkedBlockingQueue

##### 额外功能

流量控制Semaphore

无界队列的好处是put操作不会导致生产者线程阻塞，但如果无限制的存储，会产生很大的开销，所以可以在put操作前做一个限流操作，限制生产速率，避免传输通道中积压过多的产品；这时可以用到juc包下的Semaphore来实现流量控制。

使用

Semaphore相当于一个流量控制器，每个要访问资源的代码需要先获取配额permits（Semaphore.acquire())，访问结束后返还配额（Semaphore.release()）；如果配额不足，那么Semaphore会使其执行线程暂停，等待某个线程结束后返还配额时，（非公平性调度策略）唤醒等待线程。

如果在构造器中设置permits为1，那么这个Semaphore实例就是一个互斥锁，但与常见互斥锁不同，这个允许一个线程获取，另一个线程释放。

管道

PipedOutputStream和PipedInputStream是jdk中典型的生产者-消费者模式，在操作前通过调用各自的connect方法或构造器传入对方进行关联。因为生产者产生的是数据的字节形式，所以需要保证字节顺序；且因为PipedOutputStream的输出是直接作为PipedInputStream输入的，所以需要保证生产者和消费者是两个不同的线程，最好是单-单模式，不然会死锁。

生产者：PipedOutputStream，产生字节形式的数据，如果发生异常导致无法继续提供产品时，需要主动关闭。

消费者：PipedInputStream，内部维护一个类型为字节数组的循环缓冲区作为传输通道。

todo：边下载边解析的RSS阅读器实现

双缓冲区

双缓冲：缓冲区可以充当数据源和数据方之间的数据容器；使用两个或多个缓冲区来实现数据从数据源到数据使用方的移动，其中一个缓冲区填充要被数据使用方消费的数据，另一个填充来自数据源的新数据，以实现数据生产和消费的并发。

jdk中使用juc包下的Exchanger来实现双缓冲





