15. 假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到：

    这里的限制是调用方限制，不是被调用方限制。

    调用方限制：设置定时线程池`ScheduledThreadPoolExecutor`，设置有界队列，拒绝策略；

32. 用过读写锁吗，原理是什么，一般在什么场景下用。

    读写锁本质是内部维护了两个ReentrantLock，一个称为readLock，另一个称为writeLock；两个锁是互斥的，读锁是共享锁，如果当前读锁被某个线程占有，其他线程可以同时持有读锁，但是不能持有写锁；写锁是互斥锁，如果某个线程占有写锁，那么其他线程既不能占有写锁也不能占有读锁。

    读写锁一般在对事务要求较高的场景下使用，没有极高的要求。因为如果只使用独占锁，那么会有较高的性能瓶颈，现实中大部分操作都是读操作。

    类似的，MySQL中InnoDB也有类似的实现（S锁X锁）。

33. 用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。

    线程池原理：

    newCachedThreadPool：使用SynchronousQueue，适合频繁提交且执行时间短的任务，如果没有线程可用会新建，如果有使用完还未被销毁的线程，这个线程会被复用；当过了60s还没有任务来使用线程，这个线程会被自动释放。

    newFixedThreadPool：使用LinkedBlockingQueue，是个固定大小的线程池。

    参数：
    
    - corePoolSize：核心工作线程数,如果线程没有在工作也会一直存活，可设置核心线程超时关闭 （= 平均每秒任务数 * 平均每个任务花费时间）；根据二八原则
    - queueCapacity：平滑突发暴增的请求，工作线程数到达核心线程数时，任务会放到队列中，直到队列中等待时间超过系统最大容忍时间，那么就会新开线程（= 核心线程数 / 平均每个任务花费时间）* 系统容忍最大响应时间；
    - maximumPoolSize：最大线程数，超过这个数量就不会再创建线程，超出的任务进入等待队列。（= 最大任务数 - 队列容量） / 每个线程每秒处理能力
    - keepAliveTime：线程空闲时间，如果设置超时退出为true，那么线程会退出直到线程数为0，如果设为false，意味着保留核心线程，那么线程会退出直到线程数为核心线程数
    - rejectedExecutionHandler：拒绝策略，当线程数达到最大且队列已满，或线程池调用shutdown后