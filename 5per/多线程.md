15. 假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到：

    这里的限制是调用方限制，不是被调用方限制。

    调用方限制：设置定时线程池`ScheduledThreadPoolExecutor`，设置有界队列，拒绝策略；

32. 用过读写锁吗，原理是什么，一般在什么场景下用。

    读写锁本质是内部维护了两个ReentrantLock，一个称为readLock，另一个称为writeLock；两个锁是互斥的，读锁是共享锁，如果当前读锁被某个线程占有，其他线程可以同时持有读锁，但是不能持有写锁；写锁是互斥锁，如果某个线程占有写锁，那么其他线程既不能占有写锁也不能占有读锁。

    读写锁一般在对事务要求较高的场景下使用，没有极高的要求。因为如果只使用独占锁，那么会有较高的性能瓶颈，现实中大部分操作都是读操作。

    类似的，MySQL中InnoDB也有类似的实现（S锁X锁）。

33. 用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。

    线程池原理：

    newCachedThreadPool：使用SynchronousQueue，适合频繁提交且执行时间短的任务，如果没有线程可用会新建，如果有使用完还未被销毁的线程，这个线程会被复用；当过了60s还没有任务来使用线程，这个线程会被自动释放。

    newFixedThreadPool：使用LinkedBlockingQueue，是个固定大小的线程池。

    参数：
    
    - corePoolSize：核心工作线程数
    - maximumPoolSize：最大线程数，超过这个数量就不会再创建线程，超出的任务进入等待队列。
    - keepAliveTime